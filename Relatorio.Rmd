---
title: "Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável - Iniciação Científica"
author: "Nome: João Victor Lauro"
date: "Data: 04/11/2024"
output:
  html_document:
    code_folding: show
    df_print: paged
    theme: spacelab
    highlight: tango
---

<style type="text/css">
.main-container {
  max-width: 1080px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include = F}
knitr::opts_chunk$set(echo = FALSE)
```

### **Bibliotecas Utilizadas:**

```{r libraries, echo = T, include = T, message = F, warning = F}
# Bibliotecas:
library(DEoptim)
library(microbenchmark)

# Paletas de Cores Utilizadas:
  cores <- c(
    "#FF7FC6", "#D55E00", "#E69F00", "#F0E442","#0072B2", "#A2DDFF", "#009E73", ## Paleta Wong
    "#FFFFFF", "#AAAAAA", "#000000" ## Neutras
    )
```

### **Introdução**

O objetivo deste trabalho é estudar um processo de produção, cuja abordagem de controle e manutenção do sistema envolva intervalos de amostragem variáveis, para compreender o modelo probabílistico, analisar seu comportamento assintótico, e avaliar os custos de produção, inspeção, reparo e envio dos itens produzidos ao mercado.

Seja um processo de produção que, a cada unidade de tempo, produz itens individuais e independentes. Ele inicia-se operando **Sob Controle** e, em algum instante aleatório, devido a uma causa especial, fica **Fora de Controle**. Para garantir que a produção opere **Sob Controle**, a regra de monitoramento estabelece algumas situações, assegurando seu retorno às condições iniciais do processo de produção. Os tempos entre ajustes sucessivos são indepentes entre si e são denominados **Ciclos de Regeneração**. A sequência desses ciclos constituem o processo de renovação do processo. Apresenta-se a seguir a proposta de "Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável", com erros de classificação, que considera um tempo de espera **L** até a primeira inspeção após ajuste, maior que os demais intervalos de tempo **m** entre inspeções.

Esse modelo pode seguir as seguintes distribuições:

+ Tempo Contínuo $\rightarrow$ Distribuição Exponencial
+ Tempo Discreto $\rightarrow$ Distribuição Geométrica

Neste trabalho, utilizaremos a **distribuição geométrica**, com parâmetro $\pi \in [0, 1]$ para descrever o tempo de falha do processo.

<br>

### **Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável** {.tabset .tabset-pills}

#### **Hipóteses** {.tabset .tabset-pills}

**1) Modelo do Processo:**
O Processo de Produção segue uma distribuição geométrica com parâmetro $\pi \in [0, 1]$:

+ Função de Massa de Probabilidade (FMP):
$P(X = k) = (1 - \pi)^{k - 1} \cdot \pi, \quad k = 1, 2, 3, \dots$
+ Função de Distribuição Acumulada (FDA):
$P(X \leq k) = 1 - (1 - \pi)^k$
+ Função Geradora de Momentos (FGM):
$M_X(t) = \frac{\pi e^t}{1 - (1 - \pi)e^t}, \quad \forall \quad t < -\ln(1 - \pi)$
+ Esperança:
$E(X) = \frac{1}{\pi}$
+ Variância:
$\text{Var}(X) = \frac{1 - \pi}{\pi^2}$
  + A distribuição geométrica, assim como a exponencial, possuem a propriedade da falta de memória, ou seja, para qualquer $m, n \in \mathbb{N}$:
  $P(X > m + n \mid X > m) = P(X > n)$


**2) Situações do Processo:**
O Processo de Produção pode se encontrar em 2 situações:

+ Sob Controle $\rightarrow$ Proporção de itens produzidos é $p_{+}$;
+ Fora de Controle $\rightarrow$ Proporção de itens produzidos é $p_{-}$;
  + $p_{+}$ > $p_{-}$, ambas constantes;
  + Após a mudança de estado, a proporção de itens conformes diminui de $p_{+}$ para $p_{-}$;
  + Após a realização de um ajuste, a proporção de itens conformes retorna ao seu valor inicial $p_{+}$.
  
**3) Monitoramento do Processo:**
Para o monitorar o processo, inspeciona-se um único item de acordo com os seguintes critérios:

+ A primeira inspeção ocorre após a produção de **L** itens (Inspeciona-se o **L-ésimo** item);
+ As inspeções seguintes ocorrem após a produção de **m** itens (Inspeciona-se o **m-ésimo** item);
  + Essa abordagem visa diminuir o custo médio, uma vez que, após um ajuste, o processo certamente se inicia **Sob Controle** e seria mais ecônomico e razoável esperar mais tempo para realizar a primeira inspeção;
+ O item é submetido á uma única classificação, entre **Conforme** ou **Não-Conforme**, cujo tempo de execução é considerado desprezível e os itens inspecionados são descartados;
  + No primeiro caso, o processo de produção é classificado como **Sob Controle**, não ocorre intervenção, e continua operando normalmente;
  + No segundo caso, o processo de produção é classificado como **Fora de Controle**, ocorre intervenção, e é instantaneamente paralisado e ajustado;
  + Quando um item é declarado como **Conforme**, há uma incerteza se o processo estaria **Fora de Controle**;
+ Existe a probabilidade de ocorrer erros de classificação:
  + $\alpha$ $\rightarrow$ Item **Conforme**, Classificação **Não-Conforme**;
  + $\beta$ $\rightarrow$ Item **Não-Conforme**, Classificação **Conforme**;
+ Inversamente, existe a probabilidade de não ocorrer erros de classificação:
  + $(1 - \alpha)$ $\rightarrow$ Item **Conforme**, Classificação **Conforme**;
  + $(1 - \beta)$ $\rightarrow$ Item **Não-Conforme**, Classificação **Não-Conforme**.

<br>

##### **Funções da Distribuição Geométrica**

```{r funcoes1, echo = T, include = T, warning = F}
## Função 1: Calcula a probabilidade de X = k para uma distribuição geométrica
fdp.geometrica <- function(k, p) {
  if (k < 1) { ## Verifica se k é menor que 1 (valores inválidos para a distribuição geométrica)
    stop("k deve ser um número inteiro maior ou igual a 1.") ## Retorna um erro se k for inválido
  }
  fdp <- (1 - p)^(k - 1) * p ## Fórmula da probabilidade da distribuição geométrica
  return(fdp) ## Retorna a probabilidade calculada
}

## Função 2: Calcula a função de distribuição acumulada (CDF) para X <= k
fda.geometrica <- function(k, p) {
  if (k < 1) { ## Verifica se k é menor que 1 (valores inválidos para a CDF da distribuição geométrica)
    stop("k deve ser um número inteiro maior ou igual a 1.") ## Retorna um erro se k for inválido
  }
  fda <- 1 - (1 - p)^k ## Fórmula da CDF da distribuição geométrica
  return(fda) ## Retorna o valor da CDF
}

## Função 3: Gera n valores aleatórios seguindo a distribuição geométrica
gerador.geometrica <- function(n, p) {
  if (n <= 0) { ## Verifica se n é menor ou igual a zero
    stop("n deve ser maior que zero.") ## Retorna um erro se n for inválido
  }
  valores <- numeric(n) ## Cria um vetor vazio para armazenar os valores gerados
  for (i in 1:n) { ## Inicia um loop para gerar n valores
    u <- runif(1) ## Gera um número aleatório uniforme entre 0 e 1
    valores[i] <- ceiling(log(1 - u) / log(1 - p)) ## Aplica a fórmula inversa da CDF para gerar o valor geométrico
  }
  return(valores) ## Retorna os valores gerados
}

## Função 4: Calcula a média teórica da distribuição geométrica
media.geometrica <- function(p) {
  media <- 1 / p ## Fórmula para a média teórica da distribuição geométrica
  return(media) ## Retorna a média calculada
}

## Função 5: Calcula a variância teórica da distribuição geométrica
variancia.geometrica <- function(p) {
  variancia <- (1 - p) / (p^2) ## Fórmula para a variância teórica da distribuição geométrica
  return(variancia) ## Retorna a variância calculada
}
```

<br>

##### **Funções Amostrais**

```{r funcoes2, echo = T, include = T, warning = F}
## Função 6: Função para calcular a média de um vetor numérico
calcular.media <- function(vetor) {
  soma <- sum(vetor) ## Soma todos os elementos do vetor
  n <- length(vetor) ## Obtém o número de elementos no vetor
  media <- soma / n ## Calcula a média dividindo a soma pelo número de elementos
  return(media) ## Retorna o valor da média
}

## Função 7: Função para calcular a variância de um vetor numérico
calcular.variancia <- function(vetor) {
  media <- calcula_media(vetor) ## Calcula a média utilizando a função anterior
  desvios <- vetor - media ## Calcula os desvios de cada elemento em relação à média
  quadrados <- desvios^2 ## Eleva os desvios ao quadrado
  variancia <- sum(quadrados) / (length(vetor) - 1) ## Calcula a variância dividindo a soma dos quadrados pelo número de elementos menos 1
  return(variancia) ## Retorna o valor da variância
}

## Função 8: Função para calcular a mediana de um vetor numérico
calcular.mediana <- function(vetor) {
  vetor <- sort(vetor) ## Ordena o vetor em ordem crescente
  n <- length(vetor) ## Obtém o número de elementos no vetor
  if (n %% 2 == 0) { ## Verifica se o número de elementos é par
    mediana <- (vetor[n/2] + vetor[n/2 + 1]) / 2 ## Calcula a mediana como a média dos dois valores centrais
  } else { ## Caso o número de elementos seja ímpar
    mediana <- vetor[(n + 1) / 2] ## Seleciona o elemento central como a mediana
  }
  return(mediana) ## Retorna o valor da mediana
}
```

<br>

#### **Modelo Probabilístico** {.tabset .tabset-pills}

Há 3 Variáveis Aleatórias associadas ao item inspecionado:

+ X $\rightarrow$ Indica a real condição de conformidade do item:
  + Não é observável;
  + X = 1 $\rightarrow$ Item ```Conforme```;
  + X = 0 $\rightarrow$ Item ```Não-Conforme```.
+ Y $\rightarrow$ Indica o resultado de classificação do item obtida pela inspeção:
  + Y = 1 $\rightarrow$ Classificação ```Conforme```;
  + Y = 0 $\rightarrow$ Classificação ```Não-Conforme```.
+ Z $\rightarrow$ Indica o estado do processo no instante de produção do item:
  + Não é observável;
  + Z = 1 $\rightarrow$ Processo de produção ```Sob Controle```;
  + Z = 0 $\rightarrow$ Processo de produção ```Fora de Controle```.

As probabilidades relacionados à proporção de itens conformes/não-conformes são:

+ $P\{X = 1 \mid Z = 1\} = p_{+}$;
+ $P\{X = 1 \mid Z = 0\} = p_{-}$.

As probabilidades relacionados às classificações dos items inspecionados são:

+ $P\{Y = 1 \mid X = 1\} = 1 - \alpha$ $\rightarrow$ Item ```Conforme```, Classificação ```Conforme```;
+ $P\{Y = 0 \mid X = 0\} = 1 - \beta$ $\rightarrow$ Item ```Não-Conforme```, Classificação ```Não-Conforme```;
+ $P\{Y = 0 \mid X = 1\} = \alpha$ $\rightarrow$ Item ```Conforme```, Classificação ```Não-Conforme```;
+ $P\{Y = 1 \mid X = 0\} = \beta$ $\rightarrow$ Item ```Não-Conforme```, Classificação ```Conforme```.

As probabilidades relacionadas aos estados do processo são:

+ $P \{ Z_{1} = 1, ..., Z_{L} = 1 \mid Z_{0} = 1 \} = (1 - \pi)^{L}$ $\rightarrow$ Processo ```Sob Controle``` no primeiro ciclo corrente;
+ $P \{ Z_{1} = 1, ..., Z_{m} = 1 \mid Z_{0} = 1 \} = (1 - \pi)^{m}$ $\rightarrow$ Processo ```Sob Controle``` nos demais ciclos correntes;
+ $P \{ Z_{1} = 1, ..., Z_{L} = 0 \mid Z_{0} = 1 \} = \left[ 1 - (1 - \pi)^{L} \right]$ $\rightarrow$ Processo ```Fora de Controle``` no primeiro ciclo corrente;
+ $P \{ Z_{1} = 1, ..., Z_{m} = 0 \mid Z_{0} = 1 \} = \left[ 1 - (1 - \pi)^{m} \right]$ $\rightarrow$ Processo ```Fora de Controle``` nos demais ciclos correntes.

Se o processo estiver ```Sob Controle```, as probabilidades de ```Não Ajustar```/```Ajustar``` o processo são:

$$
\begin{align*}
p_{AS} 
= P \{Y = 1 \mid Z = 1 \} 
&= \sum_{i=0}^{1} P \{ Y = 1 , X = i \mid Z = 1 \} \\
&= \sum_{i=0}^{1} P \{ X = i \mid Z = 1 \} P \{ Y = 1 \mid X = i, Z = 1 \} \\
&= \left[ \underset{(1 - p_{+})}{\underbrace{P\{X = 0 \mid Z = 1\}}} 
\underset{\beta}{\underbrace{P\{Y = 1 \mid X = 0, Z = 1\}}} \right] 
+ \left[ \underset{p_{+}}{\underbrace{P\{X = 1 \mid Z = 1\}}} 
\underset{(1 - \alpha)}{\underbrace{P\{Y = 1 \mid X = 1, Z = 1\}}} \right] \\
&= \left[ (1 - p_{+}) \beta \right] + \left[ p_{+} (1 - \alpha) \right] 
\\\\
(1 - p_{AS})
= P \{Y = 0 \mid Z = 1 \}
&= 1 - \left[ ((1 - p_{+}) \beta ) + (p_{+} (1 - \alpha)) \right] \\
&= \left[ ((1 - p_{+}) (1 - \beta) ) + (p_{+} \alpha) \right]
\end{align*}
$$

Se o processo estiver ```Fora de Controle```, as probabilidades de ```Não Ajustar```/```Ajustar``` o processo são:

$$
\begin{align*}
p_{AF} 
= P \{Y = 1 \mid Z = 0 \} 
&= \sum_{i=0}^{1} P \{ Y = 1 , X = i \mid Z = 0 \} \\
&= \sum_{i=0}^{1} P \{ X = i \mid Z = 0 \} P \{ Y = 1 \mid X = i, Z = 0 \} \\
&= \left[ \underset{(1 - p_{-})}{\underbrace{P\{X = 0 \mid Z = 0\}}} 
\underset{\beta}{\underbrace{P\{Y = 1 \mid X = 0, Z = 0\}}} \right] 
+ \left[ \underset{p_{-}}{\underbrace{P\{X = 1 \mid Z = 0\}}} 
\underset{(1 - \alpha)}{\underbrace{P\{Y = 1 \mid X = 1, Z = 0\}}} \right] \\\\
&= \left[ (1 - p_{-}) \beta \right] + \left[ p_{-} (1 - \alpha) \right] 
\\\\
(1 - p_{AF})
=P \{Y = 0 \mid Z = 0 \} 
&= 1 - \left[ ((1 - p_{-}) \beta ) + (p_{-} (1 - \alpha)) \right] \\
&= \left[ ((1 - p_{-}) (1 - \beta) ) + (p_{-} \alpha) \right]
\end{align*}
$$

Resumindo:

+ $p_{AS} = P \{ Y = 1 \mid Z = 1 \} = \left[ (1 - p_{+}) \beta \right] + \left[ p_{+} (1 - \alpha) \right]$
+ $p_{AF} = P \{ Y = 1 \mid Z = 0 \} = \left[ (1 - p_{-}) \beta \right] + \left[ p_{-} (1 - \alpha) \right]$

<br>

##### **Funções do Modelo Probabilístico**

```{r funcoes3, echo = T, include = T, warning = F}
## Função 9: Calcula p_(AS) - Probabilidade de Não Ajustar o processo Sob Controle
calcular.p.AS <- function(p1, alfa, beta) {
  
  ## p1: probabilidade de conformidade do item sob controle (p_(+))
  ## alfa: probabilidade de classificar item conforme como não conforme
  ## beta: probabilidade de classificar item não conforme como conforme

  termo.1 <- (1 - p1) * beta ## Probabilidade de itens não conformes classificados como conformes
  termo.2 <- p1 * (1 - alfa) ## Probabilidade de itens conformes classificados como conformes
  p.AS <- termo.1 + termo.2 ## Soma os termos para calcular p_(AS)
  return(p.AS) ## Retorna p_(AS)
}

## Função 10: Calcula p_(AF) - Probabilidade de Não Ajustar o processo Fora de Controle
calcular.p.AF <- function(p2, alfa, beta) {
  
  ## p2: probabilidade de conformidade do item fora de controle (p_(-))
  ## alfa: probabilidade de classificar item conforme como não conforme
  ## beta: probabilidade de classificar item não conforme como conforme

  termo.1 <- (1 - p2) * beta ## Probabilidade de itens não conformes classificados como conformes
  termo.2 <- p2 * (1 - alfa) ## Probabilidade de itens conformes classificados como conformes
  p.AF <- termo.1 + termo.2 ## Soma os termos para calcular p_(AF)
  return(p.AF) ## Retorna p_(AF)
}
```

<br>

#### **Cadeia de Markov** {.tabset .tabset-pills}

O processo de produção, o monitoramento e a regra de decisão sobre o ajuste em cada ciclo de inspeção podem ser modelados como uma cadeia de Markov em tempo discreto, em que cada passado da cadeia representa um ciclo. Os estados da cadeia descrevem as várias combinações da situação do processo ao final de um ciclo e da consequente decisão.

O espaço de estados da cadeia é finito e dado por:

\[E = \{ (w,s); \; w = 0,1,2 \; \text{e} \; s = 0,1\}\]

+ W indica as situações possíveis de mudança do estado do processo:
  + W = 0 $\rightarrow$ Processo Sob Controle até o final do ciclo corrente;
  + W = 1 $\rightarrow$ Processo Fora de Controle, mudança ocorreu durante o ciclo corrente;
  + W = 2 $\rightarrow$ Processo Fora de Controle, mudança ocorreu durante no ciclo anterior;
+ S indica a decisão sobre o ajuste:
  + S = 0 $\rightarrow$ Processo é ajustado;
  + S = 1 $\rightarrow$ Processo não é ajustado.

A cadeia de Markov fica da seguinte forma:

$$
\begin{bmatrix}
P_{(0,0)(0,0)} & P_{(0,0)(0,1)} & P_{(0,0)(1,0)} & P_{(0,0)(1,1)} & P_{(0,0)(2,0)} & P_{(0,0)(2,1)} \\
P_{(0,1)(0,0)} & P_{(0,1)(0,1)} & P_{(0,1)(1,0)} & P_{(0,1)(1,1)} & P_{(0,1)(2,0)} & P_{(0,1)(2,1)} \\
P_{(1,0)(0,0)} & P_{(1,0)(0,1)} & P_{(1,0)(1,0)} & P_{(1,0)(1,1)} & P_{(1,0)(2,0)} & P_{(1,0)(2,1)} \\
P_{(1,1)(0,0)} & P_{(1,1)(0,1)} & P_{(1,1)(1,0)} & P_{(1,1)(1,1)} & P_{(1,1)(2,0)} & P_{(1,1)(2,1)} \\
P_{(2,0)(0,0)} & P_{(2,0)(0,1)} & P_{(2,0)(1,0)} & P_{(2,0)(1,1)} & P_{(2,0)(2,0)} & P_{(2,0)(2,1)} \\
P_{(2,1)(0,0)} & P_{(2,1)(0,1)} & P_{(2,1)(1,0)} & P_{(2,1)(1,1)} & P_{(2,1)(2,0)} & P_{(2,1)(2,1)} \\
\end{bmatrix}
$$

Na primeira, terceira e quinta linhas/colunas, o ciclo anterior/anterior não é ajustado;
Na segunda, quarta e sexta linhas/colunas, o ciclo anterior/seguinte é ajustado.

Com isso, as probabilidades de transição podem ser calculadas da seguinte forma:

Quando o ciclo anterior é ajustado (1º, 3º e 5º linhas), ou seja, (w,0), p/ w =  0, 1, 2:

  + $P_{(w,0)(0,0)} = (1 - \pi)^{L}(1 - p_{AS})$
    + A probabilidade de **não ocorrer** uma mudança na fração de **L** itens conformes $(1 - \pi)^{L}$ no ciclo seguinte, com a probabilidade $(1 - P_{AS})$ de **ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(w,0)(0,1)} = (1 - \pi)^{L}p_{AS}$
    + A probabilidade de **não ocorrer** uma mudança na fração de **L** itens conformes $(1 - \pi)^{L}$ no ciclo seguinte, com a probabilidade $P_{AS}$ de **não ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(w,0)(1,0)} = \left[ 1 - (1 - \pi)^{L} \right] (1 - p_{AF})$
    + A probabilidade de **ocorrer** uma mudança na fração de **L** itens conformes $\left[ 1 - (1 - \pi)^{L} \right]$ no ciclo seguinte, com a probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,0)(1,1)} = \left[ 1 - (1 - \pi)^{L} \right] p_{AF}$
    + A probabilidade de **ocorrer** uma mudança na fração de **L** itens conformes $\left[ 1 - (1 - \pi)^{L} \right]$ no ciclo seguinte, com a probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,0)(2,0)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```;
  + $P_{(w,0)(2,1)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```.
  
Quando o ciclo anterior não é ajustado e o processo está ```Sob-Controle``` (2º linha), ou seja, (0,1):

  + $P_{(0,1)(0,0)} = (1 - \pi)^{m}(1 - p_{AS})$
    + A probabilidade de **não ocorrer** uma mudança na fração de **m** itens conformes $(1 - \pi)^{m}$ no ciclo seguinte, com a probabilidade $(1 - P_{AS})$ de **ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(0,1)(0,1)} = (1 - \pi)^{m}p_{AS}$
    + A probabilidade de **não ocorrer** uma mudança na fração de **m** itens conformes $(1 - \pi)^{m}$ no ciclo seguinte, com a probabilidade $P_{AS}$ de **não ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(0,1)(1,0)} = \left[ 1 - (1 - \pi)^{m} \right] (1 - p_{AF})$
    + A probabilidade de **ocorrer** uma mudança na fração de **m** itens conformes $\left[ 1 - (1 - \pi)^{m} \right]$ no ciclo seguinte, com a probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(0,1)(1,1)} = \left[ 1 - (1 - \pi)^{m} \right] p_{AF}$
    + A probabilidade de **ocorrer** uma mudança na fração de **m** itens conformes $\left[ 1 - (1 - \pi)^{m} \right]$ no ciclo seguinte, com a probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(0,1)(2,0)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```;
  + $P_{(0,1)(2,1)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```.

Quando o ciclo anterior não é ajustado (4 e 6º linhas), ou seja, (w,1), p/ w = 1, 2:

  + $P_{(w,1)(0,0)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(0,1)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(1,0)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(1,1)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(2,0)} = 1 - p_{AF}$
    + A probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,1)(2,1)} = p_{AF}$
    + A probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```.
  
Fazendo as substituições, obtemos:

$$
\begin{bmatrix}
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
(1-p_{AS})(1-\pi)^m & p_{AS}(1-\pi)^m & (1-p_{AF})[1 - (1-\pi)^m] & p_{AF}[1 - (1-\pi)^m] & 0 & 0  \\
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
0 & 0 & 0 & 0 & 1-p_{AF} & p_{AF} \\
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
0 & 0 & 0 & 0 & 1-p_{AF} & p_{AF} \\
\end{bmatrix}
$$

<br>

##### **Funções da Cadeia de Markov**

```{r funcoes4, echo = T, include = T, warning = F}
## Função 11: Calcula a probabilidade do processo continuar "Sob Controle" por L ciclos, dado que começa "Sob Controle"
calc.p.AS.L <- function(pi, L) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## L: número de ciclos correntes

  prob.sob.controle.L <- (1 - pi)^L ## Calcula a probabilidade de o processo continuar "Sob Controle" por L ciclos
  return(prob.sob.controle.L) ## Retorna a probabilidade calculada
}

## Função 12: Calcula a probabilidade do processo continuar "Sob Controle" por m ciclos, dado que começa "Sob Controle"
calc.p.AS.m <- function(pi, m) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## m: número de ciclos correntes

  prob.sob.controle.m <- (1 - pi)^m ## Calcula a probabilidade de o processo continuar "Sob Controle" por m ciclos
  return(prob.sob.controle.m) ## Retorna a probabilidade calculada
}

## Função 13: Calcula a probabilidade de o processo passar para "Fora de Controle" após L ciclos, dado que começa "Sob Controle"
calc.p.AF.L<- function(pi, L) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## L: número de ciclos correntes

  prob.fora.controle.L <- 1 - ((1 - pi)^L) ## Calcula a probabilidade de o processo passar para "Fora de Controle" após L ciclos
  return(prob.fora.controle.L) ## Retorna a probabilidade calculada
}

## Função 14: Calcula a probabilidade de o processo passar para "Fora de Controle" após m ciclos, dado que começa "Sob Controle"
calc.p.AF.m <- function(pi, m) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## m: número de ciclos correntes

  prob.fora.controle.m <- 1 - ((1 - pi)^m) ## Calcula a probabilidade de o processo passar para "Fora de Controle" após m ciclos
  return(prob.fora.controle.m) ## Retorna a probabilidade calculada
}

calc.matriz.prob.markov <- function(p.AS, p.AF, p.AS.L, p.AF.L, p.AS.m, p.AF.m) {
  
  ## Probabilidades de transição para os diferentes estados:
  P.00.00 <- (1 - p.AS) * p.AS.L
  P.00.01 <- p.AS * p.AS.L
  P.00.10 <- (1 - p.AF) * p.AF.L
  P.00.11 <- p.AF * p.AF.L
  P.00.20 <- 0
  P.00.21 <- 0

  P.01.00 <- (1 - p.AS) * p.AS.m
  P.01.01 <- p.AS * p.AS.m
  P.01.10 <- (1 - p.AF) * p.AF.m
  P.01.11 <- p.AF * p.AF.m
  P.01.20 <- 0
  P.01.21 <- 0

  P.10.00 <- (1 - p.AS) * p.AS.L
  P.10.01 <- p.AS * p.AS.L
  P.10.10 <- (1 - p.AF) * p.AF.L
  P.10.11 <- p.AF * p.AF.L
  P.10.20 <- 0
  P.10.21 <- 0

  P.11.00 <- 0
  P.11.01 <- 0
  P.11.10 <- 0
  P.11.11 <- 0
  P.11.20 <- 1 - p.AF
  P.11.21 <- p.AF

  P.20.00 <- (1 - p.AS) * p.AS.L
  P.20.01 <- p.AS * p.AS.L
  P.20.10 <- (1 - p.AF) * p.AF.L
  P.20.11 <- p.AF * p.AF.L
  P.20.20 <- 0
  P.20.21 <- 0

  P.21.00 <- 0
  P.21.01 <- 0
  P.21.10 <- 0
  P.21.11 <- 0
  P.21.20 <- 1 - p.AF
  P.21.21 <- p.AF

  ## Matriz de transição com as probabilidades:
  matriz <- matrix(c(
    P.00.00, P.00.01, P.00.10, P.00.11, P.00.20, P.00.21,
    P.01.00, P.01.01, P.01.10, P.01.11, P.01.20, P.01.21,
    P.10.00, P.10.01, P.10.10, P.10.11, P.10.20, P.10.21,
    P.11.00, P.11.01, P.11.10, P.11.11, P.11.20, P.11.21,
    P.20.00, P.20.01, P.20.10, P.20.11, P.20.20, P.20.21,
    P.21.00, P.21.01, P.21.10, P.21.11, P.21.20, P.21.21), nrow = 6, byrow = TRUE)

  ## Nomes das linhas e colunas:
  rownames(matriz) <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)")
  colnames(matriz) <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)")

  return(matriz)
}
```

<br>

#### **Distribuição Estacionária da Cadeia** {.tabset .tabset-pills}

A matriz de transição P é irredutível e aperiódica, podendo-se obter sua distribuição invariante, denotada pelo vetor:

$$
\pi = 
\left[ 
\pi(w,s); \; w = 0,1,2; \; s = 0,1
\right]', 
\; com
\sum_{(w,s) \in E}^{}
\pi(w,s) = 1
$$

A probabilidade $\pi(w,s)$ pode ser vista como a proporção de tempo que o sistema de produção visita o estado (w,s), após um número suficientemente grande de inspeções.

O vetor $\pi$ é a solução do sistema de equações lineares $\pi' = \pi'P$, que pode ser reescrita como:

$$
\pi'(P - I) = 0'
\; ou
(P' - I)\pi = 0
$$

em que I é a matriz identidade, 0 o vetor nulo e P' é a transposta de P.

Portanto, o vetor $\pi$ pode ser obtido a partir da resolução desse sistema linear com a restrição acima. Pela dimensão do sistema, a solução pode ser rapidamente obtida utilizando-se de técnica numérica disponível

Além disso, é necessária a determinação da proporção de ciclos de comprimento L ou m, de cada estado da cadeia de Markov, para um número suficiente grande de inspeções. Sejam $p_{L}(w,s)$ a probabilidade de o intervalo de amostragem ter comprimento L, dado que o estado seja $(w,s)$ e $p_{m}(w,s)$, se o ciclo de monitoramento tiver comprimento m, com $p_{m}(w,s) = 1 - p_{l}(w,s)$

O comprimento do intervalo de amostragem é L apenas quando se decide intervir no processo no ciclo imediatamente anterior. Essa situação corresponde às linhas da Matriz P, com s = 0. Por exemplo, $p_{L}(0,0)$ denota a probabilidade do ciclo corrente ter comprimento L, dado que seu estado é (0,0). É necessário que o último item inspecionado tenha sido declarado não-conforme, ou seja, (0,0), (1,0), (2,0) são os possíveis estados do ciclo de monitoramento imediatamente anterior. Especificamente:

$$
p_{L}(0,0)
=
\sum_{k = 0}^{2}
P{(W_{i - 1}, S_{i - 1})}
=
(k,0)
|
(W_{i}, S_{i})
= 
(0,0)
$$

Em que $(W_{i}, S_{i})$ é a variável aleatória associada ao estado da cadeia de Markov da i-ésima inspeção.

Aplicando o teorema de Bayes no segundo termo, obtém-se:

$$
\frac
{
\sum_{k = 0}^{2}
P
\left[
(W_{i}, S_{i})
=
(0,0)
|
(W_{i - 1}, S_{i - 1})
= 
(k,0)
\right]
P
\left[
(W_{i - 1}, S_{i - 1})
=
(0,0)
\right]
}
{
P
\left[
(W_{i}, S_{i})
=
(0,0)
\right]
}
$$

Onde $P{(W_{i}, S_{i}) = (0,0) | (W_{i - 1}, S_{i - 1})} = (k,0)$ é a probabilidade de transição $P_{(k,0)(0,0)}, k = 0, 1, 2$, pelas propriedades da distribuição estacionária, temos:

$$
P(W_{i - 1}, S_{i - 1}) = (k,0) 
= 
P(W_{i}, S_{i}) = (k,0)
= 
\pi(k,0)
$$

Dessa maneira, podemos achar todos os valores de $p_{L}(w,s)$:

$$
p_{L}(0,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(0,0)} 
} 
{ 
\pi(0,0) 
} 
$$

$$
p_{L}(0,1) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(0,1)} 
} 
{ 
\pi(0,1) 
} 
$$

$$
p_{L}(1,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(1,0)} 
} 
{ 
\pi(1,0) 
} 
$$

$$
p_{L}(1,1) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(1,1)} 
} 
{ 
\pi(1,1) 
} 
$$

$$
p_{L}(2,0) 
= 
0
$$

$$
p_{L}(2,1) 
= 
0
$$

<br>

##### **Função da Distribuição Estacionária (c/ Autovalores e Autovetores)**

```{r funcoes7, echo = T, include = T, warning = F}
## Função 14: Calcula a distribuição estacionária para uma cadeia de Markov pelo método dos autovalores e autovetores
calcular.distribuicao.estacionaria.AV <- function(P, tol = 1e-10) {
  
  ## P: Matriz de transição de probabilidade (matriz quadrada de dimensões n x n)
  ## tol: Tolerância para a identificação do autovalor 1
  
  if (!is.matrix(P) || nrow(P) != ncol(P)) {
    stop("A matriz P deve ser quadrada.") ## Verifica se P é uma matriz quadrada
  }
  
  # Calculando autovalores e autovetores
  resultado <- eigen(t(P))  # Transposta de P para obter os autovetores da matriz de transição
  autovetores <- resultado$vectors
  autovalores <- resultado$values
  
  # Procurar o autovalor próximo de 1 dentro da tolerância
  indice_autovalor_1 <- which(abs(autovalores - 1) < tol)
  
  if (length(indice_autovalor_1) == 0) {
    stop("Não foi encontrado autovalor igual a 1 dentro da tolerância especificada.")
  }
  
  # Extrai o autovetor correspondente ao autovalor 1
  pi <- autovetores[, indice_autovalor_1]  
  pi <- Re(pi)  # Garantir que é um vetor real (caso haja pequenas partes imaginárias numéricas)
  
  # Normaliza a distribuição estacionária para que a soma das probabilidades seja 1
  pi <- pi / sum(pi)
  
  # Nomeando os estados
  n <- nrow(P)
  names(pi) <- paste0("pi.", 1:n)
  
  return(pi)
}

```

<br>

##### **Função da Distribuição Estacionária (Método LU)**

```{r funcoes5, echo = T, include = T, warning = F}
## Função 12: Calcula a distribuição estacionária para uma cadeia de Markov pelo método da decomposição LU
calcular.distribuicao.estacionaria.LU <- function(P) {
  ## Verificar se a matriz é quadrada
  if (!is.matrix(P) || nrow(P) != ncol(P)) {
    stop("A matriz de transição deve ser quadrada.")
  }
  
  n <- nrow(P)
  
  ## Modificar a matriz de transição para criar o sistema linear A * pi = 0
  A <- t(P) - diag(n)
  A[n, ] <- rep(1, n)  ## Adicionar restrição de soma das probabilidades
  
  b <- rep(0, n)
  b[n] <- 1
  
  ## Função para decomposição LU
  decomposicao_LU <- function(A) {
    n <- nrow(A)
    L <- diag(1, n)
    U <- matrix(0, n, n)
    
    for (i in 1:n) {
      for (j in i:n) {
        U[i, j] <- A[i, j] - sum(L[i, 1:(i-1)] * U[1:(i-1), j])
      }
      for (j in (i+1):n) {
        if (j <= n) {  ## Verificar limites de índices
          L[j, i] <- (A[j, i] - sum(L[j, 1:(i-1)] * U[1:(i-1), i])) / U[i, i]
        }
      }
    }
    list(L = L, U = U)
  }
  
  ## Função para resolver sistema linear L * y = b e U * x = y
  resolver_LU <- function(L, U, b) {
    n <- length(b)
    
    ## Resolver L * y = b (substituição progressiva)
    y <- numeric(n)
    for (i in 1:n) {
      y[i] <- (b[i] - sum(L[i, 1:(i-1)] * y[1:(i-1)]))
    }
    
    ## Resolver U * x = y (substituição retroativa)
    x <- numeric(n)
    for (i in n:1) {
      if (i < n) {
        x[i] <- (y[i] - sum(U[i, (i+1):n] * x[(i+1):n])) / U[i, i]
      } else {
        x[i] <- y[i] / U[i, i]
      }
    }
    
    x
  }
  
  LU <- decomposicao_LU(A) ## Decomposição LU da matriz A
  pi <- resolver_LU(LU$L, LU$U, b) ## Resolver o sistema linear A * pi = b usando a decomposição LU
  pi <- pi / sum(pi) ## Normalizar pi para garantir que a soma seja 1
  
  return(pi)
}
```

<br>

##### **Função da Distribuição Estacionária (Método QR)**

```{r funcoes6, echo = T, include = T, warning = F}
## Função 13: Calcula a distribuição estacionária para uma cadeia de Markov pelo método da decomposição QR
calcular.distribuicao.estacionaria.QR <- function(P) {
  
  ## P: Matriz de transição de probabilidade (matriz quadrada de dimensões n x n)
  
  if (!is.matrix(P) || nrow(P) != ncol(P)) {
    stop("A matriz P deve ser quadrada.") ## Verifica se P é uma matriz quadrada
  }
  
  # Calculando autovalores e autovetores
  autovetores <- eigen(t(P))$vectors  # Transposta de P para obter os autovetores da matriz de transição
  autovalores <- eigen(t(P))$values   # Autovalores da matriz
  
  # Encontrando o autovetor correspondente ao autovalor 1
  # O autovetor associado ao autovalor 1 é a distribuição estacionária
  indice_autovalor_1 <- which(abs(autovalores - 1) < 1e-10)  # Procurar o autovalor próximo de 1
  if (length(indice_autovalor_1) == 0) {
    stop("Não foi encontrado autovalor igual a 1.")
  }
  
  pi <- autovetores[, indice_autovalor_1]  # Extrai o autovetor correspondente
  pi <- Re(pi)  # Garantir que é um vetor real (caso haja pequenas partes imaginárias numéricas)
  
  # Normaliza a distribuição estacionária para que a soma das probabilidades seja 1
  pi <- pi / sum(pi)
  
  # Nomeando os estados
  n <- nrow(P)
  names(pi) <- paste0("pi.", 1:n)
  
  return(pi)
}
```

<br>

##### **Função para calcular $p_{L}$**

```{r funcoes8, echo = T, include = T, warning = F}
## Função 14: Calcula a probabilidade de transição P_L(w,s) para cada estado (w,s)
calcular.pL <- function(P, pi) {
  
  ## P: Matriz de transição de probabilidade (matriz quadrada de dimensões n x n)
  ## pi: vetor contendo as probabilidades da distribuição estacionária (pi_1, pi_2, ..., pi_n)
  
  n <- nrow(P) ## Número de estados na matriz P
  pL <- rep(0, n) ## Inicializa o vetor de resultados com zeros
  
  ## Soma dos valores de pi para os estados (0,0), (1,0), (2,0)
  soma.pi <- pi[1] + pi[3] + pi[5]  # Soma das probabilidades dos estados (w,s)
  
  ## Calculando as probabilidades de transição p_L(w,s) para cada estado (w,s)
  pL[1] <- (soma.pi * P[1,1]) / (pi[1]) ## P_L(0,0)
  pL[2] <- (soma.pi * P[1,2]) / (pi[2]) ## P_L(0,1)
  pL[3] <- (soma.pi * P[1,3]) / (pi[3]) ## P_L(1,0)
  pL[4] <- (soma.pi * P[1,4]) / (pi[4]) ## P_L(1,1)
  pL[5] <- 0  ## P_L(2,0)
  pL[6] <- 0  ## P_L(2,1)
  
  return(pL)
}
```

<br>

#### **Custo dos Estados** {.tabset .tabset-pills}

A estrutura de custo considerada é similar áquela adotada por e em trabalhos anteriores. Consideram três componentes de custo:

+ $c_{ìnspeção}$ $\rightarrow$ É o custo de classificação de um item inspecionado e está presente em todos os estados da cadeia;
+ $c_{ajuste}$ $\rightarrow$ É o custo de ajustar o processo.
+ $c_{descarte(c)}$ $\rightarrow$ Custo de descartar item conforme;
+ $c_{descarte(nc)}$ $\rightarrow$ Custo de descartar item não conforme;
+ $c_{nc}$ $\rightarrow$ É o custo de item defeituoso que segue para o consumidor final ou para as próximas etapas do processo;

Os componentes $c_{s.nc}$ $c_{s.c}$ são usados nas situações em que os itens descartados são submetidos a processos de reaproveitamento com custos diferenciados entre itens conformes e não-conformes. No caso de os itens inspecionados serem simplesmente descartados, deve-se utiilizar o custo unitário de produção, desconsiderado o sistema de controle.

A expressão geral do custo esperado de cada estado (w,s), w = 0, 1, 2 e s = 0, 1 é dada por:

+ $\phi (w,s) = c_{ìnspeção} + \varepsilon (w,s) + \theta (w,s) + c_{ajuste}$

em que:

+ $\varepsilon (w,s)$ $\rightarrow$ É o custo esperado por ciclo referente aos itens não-conformes dentre os m - 1 ou L - 1 itens não inspecoinados que são enviados aao mercado ou às próximas etapas da produção;
+ $\theta (w,s)$ $\rightarrow$ É o custo esperado por ciclo relacionado ao item inspecionado, descartado;

<br>

##### **Custo dos estados (0,0) e (0,1)**

O item é inspecionado é classificado como conforme, mas, devido aos erros de classificação, ele pode ser realmente conforme ou não-conforme. A probabilidade do item inspecionado, declarado conforme, ser realmente conforme é:

$$
P \{ X = 1 \mid Y = 1, Z = 1 \} 
= 
\frac 
{ 
P \{ X = 1, Y = 1 \mid Z = 1 \} 
} 
{ 
P \{ Y = 1 \mid Z = 1 \} 
} 
= 
\frac 
{ 
p_{+} 
(1 - \alpha) 
} 
{ 
p_{AS} 
} 
$$

E de ser realmente não-conforme é:

$$
P \{ X = 0 \mid Y = 1, Z = 1 \} 
= 
\frac 
{ 
P \{ X = 0, Y = 1 \mid Z = 1 \} 
} 
{ 
P \{ Y = 1 \mid Z = 1 \} 
} 
= 
\frac 
{ 
(1 - p_{+}) 
\beta 
} 
{ 
p_{AS} 
} 
$$

<br>

Para o estado $(0, 0)$:

$$
\xi (0,0) 
= 
c_{nc} 
\left[ 
p_{m}(0,0) 
(m - 1) 
(1 - p_{+}) 
+ 
p_{L}(0,0) 
(L - 1) 
(1 - p_{+}) 
\right] 
$$

$$
\theta(0, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{+} \alpha 
} 
{1 - p_{AS} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{+}) 
(1 - \beta) 
} 
{ 
1 - p_{AS} 
} 
$$

$$
\phi(0, 0) 
= 
c_{ìnspeção} 
+ 
\xi(0, 0) 
+ 
\theta(0, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(0, 1)$:

$$
\xi (0,1) 
= 
c_{nc} 
\left[ 
p_{m}(0,1) 
(m - 1) 
(1 - p_{+}) 
+ 
p_{L}(0,1) 
(L - 1) 
(1 - p_{+}) 
\right] 
$$

$$
\theta(0, 1) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{+} (1 - \alpha) 
} 
{ 
p_{AS} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{+}) 
\beta
} 
{ 
p_{AS} 
} 
$$

$$
\phi(0, 1) 
= 
c_{ìnspeção} 
+ 
\xi(0, 1) 
+ 
\theta(0, 1) 
$$

<br>

##### **Custo dos estados (1,0) e (1,1)**

Quando a fração de conformidade se modifica durante o ciclo corrente, pelo menos um item inspecionado é produzido com o processo fora de controle. O ponto de mudança pode ocorrer em qualquer instante entre o primeiro e o último item produzido durante o ciclo. Em ciclos com intervalo entre amostragens de comprimento $m$, a probabilidade de a mudança de estado ocorrer no instante $t$ é dada por:

$$
q_{m}(t) = 
\frac 
{ 
(1 - \pi)^{t - 1} 
\pi 
} 
{ 
1 - (1 - \pi)^m 
} 
, \quad t = 1, \dots, m 
$$

Analogamente, quando o intervalo entre inspeções tem comprimento \(L\), essa probabilidade é:

$$
q_{L}(t) = 
\frac 
{ 
(1 - \pi)^{t - 1} 
\pi 
} 
{ 
1 - (1 - \pi)^L 
} 
, \quad t = 1, \dots, L 
$$

<br>

Para o estado $(1, 0)$:

$$
\xi(1, 0) 
= 
c_{nc} 
\Bigg[ 
p_{m}(1, 0) 
\sum_{t = 1}^{m} 
q_{m}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(m - t) 
(1 - p_{-}) 
\big] 
+ 
p_L(1, 0) 
\sum_{t=1}^{L} 
q_{L}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(L - t) 
(1 - p_{-}) 
\big] 
\Bigg] 
$$

$$
\theta(1, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
\alpha 
} 
{ 
1 - p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{-}) 
(1 - \beta) 
} 
{ 
1 - p_{AF} 
} 
$$

$$
\phi(1, 0) 
= 
c_{ìnspeção} 
+ 
\xi(1, 0) 
+ 
\theta(1, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(1, 1)$:

$$
\xi(1, 1) 
= 
c_{nc} 
\Bigg[ 
p_{m}(1, 1) 
\sum_{t = 1}^{m} 
q_{m}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(m - t) 
(1 - p_{-}) 
\big] 
+ 
p_L(1, 1) 
\sum_{t=1}^{L} 
q_{L}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(L - t) 
(1 - p_{-}) 
\big] 
\Bigg] 
$$

$$
\theta(1, 1) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
(1 - \alpha) 
} 
{ 
p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{-}) 
\beta 
} 
{ 
p_{AF} 
} 
$$

$$
\phi(1, 1) 
= 
c_{ìnspeção} 
+ 
\xi(1, 1) 
+ 
\theta(1, 1) 
$$

<br>

##### **Custo dos Estados (2, 0) e (2, 1)**

Para o estado $(2, 0)$:

$$
\xi(2, 0) 
= 
c_{nc} 
(1 - p_{-}) 
(m - 1) 
$$

$$
\theta(2, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
\alpha 
} 
{ 
1 - p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ (1 - p_{-}) 
(1 - \beta) 
} 
{ 
1 - p_{AF} 
} 
$$

$$
\phi(2, 0) 
= 
c_{ìnspeção} 
+ 
\xi(2, 0) 
+ 
\theta(2, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(2, 1)$:

$$
\xi(2, 1) 
= 
c_{nc} 
(1 - p_{-}) 
(m - 1) 
$$

$$
\theta(2, 1) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
(1 - \alpha) 
} 
{ 
p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ (1 - p_{-}) 
\beta 
} 
{ 
p_{AF} 
} 
$$

$$
\phi(2, 1) 
= 
c_{ìnspeção} 
+ 
\xi(2, 1) 
+ 
\theta(2, 1) 
$$

<br>

##### **Funções dos Custos dos Estados**

```{r funcoes9, echo = T, include = T, warning = F}
## Função 15.1: com loops for para calcular os custos dos estados
calcular.custos.1 <- function(p.mais, p.menos, alfa, beta, 
                              c.inspecao, c.ajuste, c.desc.c, c.desc.nc, c.nc,
                              p.AS, p.AF, pi, p.L, L, m) {
  
  ## Função auxiliar para calcular q.m(t) ou q.L(t) (vetorizada)
  calcular.q <- function(t, pi, comprimento) {
    numerador <- (1 - pi)^(t - 1) * pi
    denominador <- 1 - (1 - pi)^comprimento
    return(numerador / denominador)
  }
  
  ## Calcular q.m(t) e q.L(t) para os valores possíveis de t (vetorizado)
  q.m <- calcular.q(1:m, pi, m) ## Vetor q.m(t)
  q.L <- calcular.q(1:L, pi, L) ## Vetor q.L(t)
  
  ## Soma de q.m(t) e q.L(t) para os cálculos em estados (1,0) e (1,1)
  soma.q.m <- sum(q.m * ((1:m - 1) * (1 - p.mais) + (m - 1:m) * (1 - p.menos)))
  soma.q.L <- sum(q.L * ((1:L - 1) * (1 - p.mais) + (L - 1:L) * (1 - p.menos)))

  estado <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)") ## Lista de estados possíveis
  resultado <- list() ## Inicializando lista para armazenar resultados

  ## Loop para calcular os custos de cada estado
  for (s in estado) {
    if (s == "(0,0)") { ## Caso o estado seja "(0,0)"
      p.L.00 <- p.L[1]
      p.m.00 <- (1 - p.L.00)
      
      xi <- c.nc * ((p.m.00 * (m - 1) * (1 - p.mais)) + (p.L.00 * (L - 1) * (1 - p.mais)))
      theta <- (c.desc.c * (p.mais * alfa)) / (1 - p.AS) + 
               (c.desc.nc * ((1 - p.mais) * (1 - beta))) / (1 - p.AS)
      psi <- c.ajuste
      phi <- c.inspecao + xi + theta + psi

    } else if (s == "(0,1)") { ## Caso o estado seja "(0,1)"
      p.L.01 <- p.L[2]
      p.m.01 <- (1 - p.L.01)
      
      xi <- c.nc * ((p.m.01 * (m - 1) * (1 - p.mais)) + (p.L.01 * (L - 1) * (1 - p.mais)))
      theta <- (c.desc.c * (p.mais * (1 - alfa))) / p.AS + 
               (c.desc.nc * ((1 - p.mais) * beta)) / p.AS
      psi <- 0
      phi <- c.inspecao + xi + theta + psi

    } else if (s == "(1,0)") { ## Caso o estado seja "(1,0)"
      p.L.10 <- p.L[3]
      p.m.10 <- (1 - p.L.10)
      
      xi <- c.nc * ((p.m.10 * soma.q.m) + (p.L.10 * soma.q.L))
      theta <- c.desc.c * (p.menos * alfa) / (1 - p.AF) + 
               c.desc.nc * ((1 - p.menos) * (1 - beta)) / (1 - p.AF)
      psi <- c.ajuste
      phi <- c.inspecao + xi + theta + psi

    } else if (s == "(1,1)") { ## Caso o estado seja "(1,1)"
      p.L.11 <- p.L[4]
      p.m.11 <- (1 - p.L.11)
      
      xi <- c.nc * ((p.m.11 * soma.q.m) + (p.L.11 * soma.q.L))
      theta <- c.desc.c * (p.menos * (1 - alfa)) / p.AF + 
               c.desc.nc * ((1 - p.menos) * beta) / p.AF
      psi <- 0
      phi <- c.inspecao + xi + theta + psi

    } else if (s == "(2,0)") { ## Caso o estado seja "(2,0)"
      xi <- c.nc * (1 - p.menos) * (m - 1)
      theta <- c.desc.c * (p.menos * alfa) / (1 - p.AF) + 
               c.desc.nc * ((1 - p.menos) * (1 - beta)) / (1 - p.AF)
      psi <- c.ajuste
      phi <- c.inspecao + xi + theta + psi

    } else if (s == "(2,1)") { ## Caso o estado seja "(2,1)"
      xi <- c.nc * (1 - p.menos) * (m - 1)
      theta <- c.desc.c * (p.menos * (1 - alfa)) / p.AF + 
               c.desc.nc * ((1 - p.menos) * beta) / p.AF
      psi <- 0
      phi <- c.inspecao + xi + theta + psi
    }

    ## Armazenar os resultados do estado atual na lista 'resultado'
    resultado[[s]] <- list(xi = xi, theta = theta, psi = psi, phi = phi)
  }

  ## Organizar os resultados em um data.frame
  df.resultado <- data.frame(
    Estado = estado,
    xi = sapply(resultado, function(x) x$xi),
    theta = sapply(resultado, function(x) x$theta),
    psi = sapply(resultado, function(x) x$psi),
    phi = sapply(resultado, function(x) x$phi)
  )

  return(df.resultado)
}
```

#### **Custo Médio e Unitário** {.tabset .tabset-pills}

Seja o processo de Renovação $\{N(t), t \geq 0\}$ que conta a quantidade de ajustes do processo até a produção do t-ésimo item. Considere $\Phi_{i}^{*}$ e $T_{i}^{*}$, $i \geq 1$ variáveis aleatórias associadas, respectivamente, ao custo e à quantidade de itens produzidos no i-ésimo ciclo de regeneração do processo

\[
C_{\text{médio}} = \frac{\sum_{i=1}^{n} \pi_i \left( c_{\text{inspeção}} + \xi_i + \theta_i + \phi_i \right)}{\sum_{i=1}^{n} \pi_i \left[ (L - 1) \cdot p_L + (m - 1) \cdot (1 - p_L) \right]}
\]

##### **Função do Custo Médio**

```{r funcoes10, echo = T, include = T, warning = F}
## Função para calcular o custo médio C(m, L)
calcular.custo.medio <- function(custos,
                                 pi, p.L, L, m) {
  
  numerador <- 0  ## Inicializa o numerador
  denominador <- 0  ## Inicializa o denominador
  
  for (i in 1:length(pi)) { ## Loop para calcular o numerador e denominador
    numerador <- numerador + (pi[i] * custos$phi[i]) ## Somatório do numerador
    denominador <- denominador + (pi[i] * (((L - 1) * p.L[i]) + ((m - 1) * (1 - p.L[i])))) ## Somatório do denominador
  }
  
  custo.medio <- numerador / denominador ## Cálculo final do custo médio
  
  return(custo.medio)
}
```

<br>

#### **Aplicação Numérica e Análise de Sensibilidade** {.tabset .tabset-pills}

Geralmente, o procedimento discutido aqui pode melhorar processos de alta qualidade que empregam algum tipo de controle automático através da coleta de observações individuais.

Com isso, consideramos o seguinte exemplo:

A fabricação de circuitos integrados de alto volume apresenta dificuldades com o processo de solda, tais como "insuficiência ou excesso de solda", "projeção de solda" ou posicionamento incorreto de dispositivo ou filete". Dados históricos permitem adotar, em um processo de solda, $p_{+} = 0,999$ como a probabilidade de conformidade do processo sob controle, podendo-se usar uma distribuição geométrica com parâmetro $\pi = 0,0001$ para descrever a mudança de estado do processo, operando fora de controle, com fração de conformidade $p_{-} = 0,95$. O sistema automático de inspeção por raio X instalado na linha de produção é imperfeito, assumindo-se os erros de inspeção $\alpha = \beta = 0,01$. Os componentes de custo são estimados em $c_{inspeção} = \$ \; 0,25$, $c_{ajuste} = \$ \; 100$, $c_{nc} = \$ \; 20$, $c_{descarte(c)} = \$ \; 2$, $c_{descarte(nc)} = \$ \; 2$.

```{r parametros, echo = T, include = T, warning = F}
## Parâmetros probabilísticos do processo:
p1 <- 0.999 		## Fracao de conformes em processo sob controle
p2 <- 0.95 		  ## Fracao de conformes em processo fora de controle
pe <- 0.0001 		## Probabilidade de ocorrencia shift do processo
alfa <- 0.01 		## Probabilidade de classificar item conforme como nao conforme
beta <- 0.01 		## Probabilidade de classificar item nao conforme como conforme

## Componentes de custo:
c.inspecao <- 0.25 	## Custo de inspecao
c.ajuste <- 100 		## Custo de ajuste
c.nc <- 20 		      ## Custo de enviar items nao-conformes
c.descarte.c <- 2 	## Custo de item conforme inspecionado/descartado
c.descarte.nc <- 2 	## Custo de item nao-conforme inspecionado/descartado]

L.teste <- 896 ## Valor de L para teste
m.teste <- 41 ## Valor de m para teste
```

<br>

##### **Cálculo dos Valores**

```{r aplicacao.1, echo = T, include = T, warning = F}
val.p.AS <- calcular.p.AS(p1, alfa, beta) ## Calcula a probabilidade de estar sob controle (P.AS)
val.p.AF <- calcular.p.AF(p2, alfa, beta) ## Calcula a probabilidade de estar fora de controle (P.AF)

val.p.AS.L <- calc.p.AS.L(pe, L.teste) ## Calcula a probabilidade de estar sob controle para L
val.p.AF.L <- calc.p.AF.L(pe, L.teste) ## Calcula a probabilidade de estar fora de controle para L
val.p.AS.m <- calc.p.AS.m(pe, m.teste) ## Calcula a probabilidade de estar sob controle para m
val.p.AF.m <- calc.p.AF.m(pe, m.teste) ## Calcula a probabilidade de estar fora de controle para m

matriz.P <- calc.matriz.prob.markov(val.p.AS, val.p.AF, 
                                    val.p.AS.L, val.p.AF.L, val.p.AS.m, val.p.AF.m) ## Calcula a matriz de probabilidades de transição

PI.AV <- calcular.distribuicao.estacionaria.AV(matriz.P) ## Calcula a distribuição estacionária usando o método QR
PI.LU <- calcular.distribuicao.estacionaria.LU(matriz.P) ## Calcula a distribuição estacionária usando o método QR
PI.QR <- calcular.distribuicao.estacionaria.QR(matriz.P) ## Calcula a distribuição estacionária usando o método QR]

p.L <- calcular.pL(matriz.P, PI.QR) ## Calcula a probabilidade de transição usando QR

custos.teste.1 <- calcular.custos.1(p.mais = p1, p.menos = p2, alfa = alfa, beta = beta, 
                                  c.inspecao = c.inspecao, c.ajuste = c.ajuste, c.desc.c = c.descarte.c, c.desc.nc = c.descarte.nc, c.nc = c.nc, 
                                  p.AS = val.p.AS, p.AF = val.p.AF, pi = PI.QR, p.L = p.L, L = L.teste, m = m.teste);

custo.medio.teste.1 <- calcular.custo.medio(custos = custos.teste.1,
                                          pi = PI.QR, p.L = p.L, L = L.teste, m = m.teste)
```

<br>

##### **Resultados**

```{r aplicacao.2, echo = T, include = T, warning = F}
cat("P.AS:", val.p.AS, "\n", ## Imprime a probabilidade P.AS
    "P.AF:", val.p.AF, "\n") ## Imprime a probabilidade P.AF

cat("P.AS.L:", val.p.AS.L, "\n",  ## Imprime a probabilidade P.AS.L
    "P.AF.L:", val.p.AF.L, "\n",  ## Imprime a probabilidade P.AF.L
    "P.AS.m:", val.p.AS.m, "\n",  ## Imprime a probabilidade P.AS.m
    "P.AF.m:", val.p.AF.m, "\n")  ## Imprime a probabilidade P.AF.m

cat("Matriz de Transição (P):\n"); matriz.P; rowSums(matriz.P) ## Imprime a matriz de transição P

cat("\nDistribuição Estacionária p/ método AV:\n", PI.AV,
    "\nDistribuição Estacionária p/ método LU:\n", PI.LU,
    "\nDistribuição Estacionária p/ método QR:\n", PI.QR)## Imprime a distribuição estacionária obtida utilizando os 3 métodos

cat("\nProbabilidades de Transição:\n", p.L) ## Imprime as probabilidades de transição

custos.teste.1
cat("Custo Médio 1:", custo.medio.teste.1)
```

<br>

##### **Tempo de Execução das Funções**

```{r aplicacao.3, echo = T, include = T, warning = F}
summary(microbenchmark(
  AV = calcular.distribuicao.estacionaria.AV(matriz.P), 
  LU = calcular.distribuicao.estacionaria.LU(matriz.P), 
  QR = calcular.distribuicao.estacionaria.QR(matriz.P), 
  times = 500)) ## Compara o tempo de execução entre as funções com microbenchmark

summary(microbenchmark(
  C1 = calcular.custos.1(p.mais = p1, p.menos = p2, alfa = alfa, beta = beta, c.inspecao = c.inspecao, c.ajuste = c.ajuste, c.desc.c = c.descarte.c, c.desc.nc = c.descarte.nc, c.nc = c.nc, p.AS = val.p.AS, p.AF = val.p.AF, p.L = p.L, pi = PI.QR, L = L.teste, m = m.teste), 
  times = 500)) ## Compara o tempo de execução entre as funções com microbenchmark
```

<br>

#### **Otimização Discreta** {.tabset .tabset-pills}

##### **Blind Search**

```{r otimizacao.1, echo = T, include = T, warning = F}
## Parâmetros probabilísticos do processo:
p1 <- 0.999 		## Fracao de conformes em processo sob controle
p2 <- 0.95 		  ## Fracao de conformes em processo fora de controle
pe <- 0.0001 		## Probabilidade de ocorrencia shift do processo
alfa <- 0.01 		## Probabilidade de classificar item conforme como nao conforme
beta <- 0.01 		## Probabilidade de classificar item nao conforme como conforme

## Componentes de custo:
c.inspecao <- 0.25 	## Custo de inspecao
c.ajuste <- 100 		## Custo de ajuste
c.nc <- 20 		      ## Custo de enviar items nao-conformes
c.descarte.c <- 2 	## Custo de item conforme inspecionado/descartado
c.descarte.nc <- 2 	## Custo de item nao-conforme inspecionado/descartado]

## Definir os valores possíveis para L e m
valores_L <- seq(800, 900, by = 4) # Ajuste os intervalos conforme necessário
valores_m <- seq(10, 100, by = 2)

## Calcular valores fixos que não dependem de L ou m
val.p.AS <- calcular.p.AS(p1, alfa, beta)
val.p.AF <- calcular.p.AF(p2, alfa, beta)

## Criar um data.frame para armazenar os resultados
resultados.gerais <- data.frame(L = integer(), m = integer(), custo_medio = numeric())

for (m_teste in valores_m) {
  for (L_teste in valores_L) {
    
    val.p.AS.L.busca <- calc.p.AS.L(pe, L.teste) ## Calcula a probabilidade de estar sob controle para L
    val.p.AF.L.busca <- calc.p.AF.L(pe, L.teste) ## Calcula a probabilidade de estar fora de controle para L
    val.p.AS.m.busca <- calc.p.AS.m(pe, m.teste) ## Calcula a probabilidade de estar sob controle para m
    val.p.AF.m.busca <- calc.p.AF.m(pe, m.teste) ## Calcula a probabilidade de estar fora de controle para m

    matriz.P.busca <- calc.matriz.prob.markov(val.p.AS, val.p.AF, 
                                              val.p.AS.L.busca, val.p.AF.L.busca, val.p.AS.m.busca, val.p.AF.m.busca) ## Calcula a matriz de probabilidades de transição
    PI.busca <- calcular.distribuicao.estacionaria.QR(matriz.P.busca) ## Calcula a distribuição estacionária usando o método QR
    p.L.busca <- calcular.pL(matriz.P.busca, PI.busca) ## Calcula a probabilidade de transição usando QR

    custos.busca <- calcular.custos.1(p.mais = p1, p.menos = p2, alfa = alfa, beta = beta, 
                                      c.inspecao = c.inspecao, c.ajuste = c.ajuste, c.desc.c = c.descarte.c, c.desc.nc = c.descarte.nc, c.nc = c.nc, 
                                      p.AS = val.p.AS, p.AF = val.p.AF, pi = PI.busca, p.L = p.L.busca, L = L_teste, m = m_teste);

    custo.medio.busca <- calcular.custo.medio(custos = custos.busca,
                                              pi = PI.busca, p.L = p.L.busca, L = L_teste, m = m_teste)
    
    resultados.gerais <- rbind(resultados.gerais, data.frame(L = L_teste, m = m_teste, custo.medio = custo.medio.busca))
  }
}

## Identifica a combinação que minimiza o custo
melhor.combinacao <- resultados.gerais[which.min(resultados.gerais$custo.medio), ]
cat("Melhor combinação encontrada:\n")
print(melhor.combinacao)
resultados.gerais
```

##### **Hill Climbing**

```{r otimizacao.2, echo = T, include = T, warning = F}
hill.climbing <- function(valores.L, valores.m, calcular.custo) {
  ## Inicializar com uma solução aleatória
  L.atual <- sample(valores.L, 1)
  m.atual <- sample(valores.m, 1)
  custo.atual <- calcular.custo(L.atual, m.atual)
  
  ## Parâmetros
  delta.L <- 4
  delta.m <- 2
  melhorou <- TRUE
  
  while (melhorou) {
    melhorou <- FALSE
    ## Gerar vizinhos
    vizinhos <- expand.grid(
      L = c(L.atual - delta.L, L.atual, L.atual + delta.L),
      m = c(m.atual - delta.m, m.atual, m.atual + delta.m)
    )
    vizinhos <- vizinhos[vizinhos$L %in% valores.L & vizinhos$m %in% valores.m, ]
    
    ## Avaliar vizinhos
    for (i in 1:nrow(vizinhos)) {
      L.viz <- vizinhos$L[i]
      m.viz <- vizinhos$m[i]
      custo.viz <- calcular.custo(L.viz, m.viz)
      
      if (custo.viz < custo.atual) {
        ## Atualizar se encontrar melhor solução
        L.atual <- L.viz
        m.atual <- m.viz
        custo.atual <- custo.viz
        melhorou <- TRUE
      }
    }
  }
  
  return(data.frame(L = L.atual, m = m.atual, custo = custo.atual))
}

## Exemplo de uso
calcular.custo <- function(L, m) {
  ## Substituir por lógica de cálculo do custo médio
  return(runif(1, 0, 100)) ## Exemplo aleatório
}

valores.L <- seq(800, 900, by = 4)
valores.m <- seq(10, 100, by = 2)

# Hill Climbing
resultado.hc <- hill.climbing(
  valores.L, valores.m, 
  calcular.custo = calcular.custo.medio(
    custos = custos.busca,
    pi = PI.busca, p.L = p.L.busca, L = L.teste, m = m.teste
  )
)

print("Resultado Hill Climbing:")
print(resultado.hc)
```

##### **Tabu Search**

```{r otimizacao.3, echo = T, include = T, warning = F}
tabu.search <- function(valores.L, valores.m, calcular.custo, max.iter = 100, tabu.tam = 10) {
  ## Inicializar solução
  L.atual <- sample(valores.L, 1)
  m.atual <- sample(valores.m, 1)
  custo.atual <- calcular.custo(L.atual, m.atual)
  
  ## Parâmetros
  tabu.list <- list()
  melhor.solucao <- data.frame(L = L.atual, m = m.atual, custo = custo.atual)
  
  for (iter in 1:max.iter) {
    ## Gerar vizinhos
    vizinhos <- expand.grid(
      L = c(L.atual - 4, L.atual, L.atual + 4),
      m = c(m.atual - 2, m.atual, m.atual + 2)
    )
    vizinhos <- vizinhos[vizinhos$L %in% valores.L & vizinhos$m %in% valores.m, ]
    
    ## Avaliar vizinhos e ignorar os tabu
    melhor.vizinho <- NULL
    melhor.custo <- Inf
    for (i in 1:nrow(vizinhos)) {
      L.viz <- vizinhos$L[i]
      m.viz <- vizinhos$m[i]
      
      ## Verificar se a combinação (L.viz, m.viz) está na lista tabu
      if (any(sapply(tabu.list, function(x) all(x == c(L.viz, m.viz))))) {
        next ## Ignorar vizinho se está na lista tabu
      }
      
      custo.viz <- calcular.custo(L.viz, m.viz)
      if (custo.viz < melhor.custo) {
        melhor.vizinho <- c(L.viz, m.viz)
        melhor.custo <- custo.viz
      }
    }
    
    ## Atualizar solução
    if (!is.null(melhor.vizinho)) {
      L.atual <- melhor.vizinho[1]
      m.atual <- melhor.vizinho[2]
      custo.atual <- melhor.custo
      
      ## Atualizar melhor solução
      if (custo.atual < melhor.solucao$custo) {
        melhor.solucao <- data.frame(L = L.atual, m = m.atual, custo = custo.atual)
      }
      
      ## Atualizar lista tabu
      tabu.list <- c(tabu.list, list(c(L.atual, m.atual)))
      if (length(tabu.list) > tabu.tam) {
        tabu.list <- tabu.list[-1]
      }
    }
  }
  
  return(melhor.solucao)
}

valores.L <- seq(800, 900, by = 4)
valores.m <- seq(10, 100, by = 2)

## Tabu Search
resultado.ts <- tabu.search(
  valores.L, valores.m, 
  calcular.custo = calcular.custo.medio(
    custos = custos.busca,
    pi = PI.busca, p.L = p.L.busca, L = L.teste, m = m.teste
  ), 
  max.iter = 50, tabu.tam = 5
)

print("Resultado Tabu Search:")
print(resultado.ts)
```
